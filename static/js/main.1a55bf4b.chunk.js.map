{"version":3,"sources":["../../src/utils/helpers.js","../../src/utils/validators.js","../../src/hooks/useValidatedState.js","App.js","index.js"],"names":["passes","rule","value","params","rules","isRequired","isBlank","testRegex","regex","size","type","parseFloat","sizeText","canUseMoment","window","toSentence","arr","valueOrEmptyString","getValidation","validation","Object","getOptions","Array","getMessage","field","options","message","humanizeFieldName","normalizeValues","accepted","val","required","after","moment","messageReplace","after_or_equal","alpha","alpha_space","alpha_num","alpha_num_space","alpha_num_dash","alpha_num_dash_space","array","before","before_or_equal","between","boolean","card_exp","card_num","currency","date","date_equals","email","in","integer","max","min","not_in","not_regex","RegExp","numeric","phone","string","typeof","url","initialValue","validations","fieldName","useState","state","setState","errors","setErrors","newValue","errorList","App","useValidatedState","name","nameErrors","setName","emailErrors","setEmail","onChange","event","target","length","map","error","index","key","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.1a55bf4b.chunk.js","sourcesContent":["export const passes = (rule, value, params, rules) => {\n  // eslint-disable-next-line no-prototype-builtins\n  if (!rules.hasOwnProperty(rule)) {\n    return true\n  }\n\n  if (!isRequired(rule, rules) && isBlank(value)) {\n    return true\n  }\n\n  return rules[rule].rule(value, params) !== false\n}\n\nexport const isRequired = (rule, rules) => {\n  // eslint-disable-next-line no-prototype-builtins\n  return rules[rule].hasOwnProperty('required') && rules[rule].required\n}\n\nexport const isBlank = (value) => {\n  return (\n    typeof value === 'undefined' ||\n    value === null ||\n    testRegex(value, /^[\\s]*$/)\n  )\n}\n\nexport const testRegex = (value, regex) => {\n  return value.toString().match(regex) !== null\n}\n\nexport const size = (value, type) => {\n  if (type === 'string' || type === undefined || type === 'array') {\n    return value.length\n  } else if (type === 'num') {\n    return parseFloat(value)\n  }\n}\n\nexport const sizeText = (type) => {\n  if (type === 'string' || type === undefined) {\n    return ' characters'\n  } else if (type === 'array') {\n    return ' elements'\n  } else {\n    return ''\n  }\n}\n\nexport const canUseMoment = () => {\n  return !(!window || !window.moment)\n}\n\nexport const toSentence = (arr) => {\n  return (\n    arr.slice(0, -2).join(', ') +\n    (arr.slice(0, -2).length ? ', ' : '') +\n    arr.slice(-2).join(arr.length > 2 ? ', or ' : ' or ')\n  )\n}\n\nexport const valueOrEmptyString = (value) => {\n  return typeof value === 'undefined' || value === null ? '' : value\n}\n\nexport const getValidation = (validation) => {\n  if (validation === Object(validation) && !!Object.keys(validation).length) {\n    return Object.keys(validation)[0]\n  } else {\n    return validation.split(':')[0]\n  }\n}\n\nexport const getOptions = (validation) => {\n  if (validation === Object(validation) && !!Object.values(validation).length) {\n    const params = Object.values(validation)[0]\n    return Array.isArray(params) ? params : [params]\n  } else {\n    const params = validation.split(':')\n    return params.length > 1 ? params[1].split(',') : []\n  }\n}\n\nexport const humanizeFieldName = (field) =>\n  field\n    .replace(/([A-Z])/g, ' $1')\n    .replace(/_/g, ' ')\n    .toLowerCase()\n\nexport const getMessage = (rule, field, options, rules) => {\n  options.messages = options.messages || {}\n  const message =\n    options.messages[rule] || options.messages.default || rules[rule].message\n  return message.replace(':attribute', humanizeFieldName(field))\n}\n\nexport const normalizeValues = (value, validation) => {\n  return [\n    valueOrEmptyString(value),\n    getValidation(validation),\n    getOptions(validation)\n  ]\n}\n","import {\n  canUseMoment,\n  isBlank,\n  size,\n  sizeText,\n  testRegex,\n  toSentence\n} from './helpers'\n\nexport default {\n  accepted: {\n    message: 'The :attribute must be accepted.',\n    rule: (val) => val === true,\n    required: true\n  },\n  after: {\n    message: 'The :attribute must be after :date.',\n    rule: (val, params) =>\n      // eslint-disable-next-line no-undef\n      canUseMoment() && moment.isMoment(val) && val.isAfter(params[0], 'day'),\n    messageReplace: (message, params) =>\n      message.replace(':date', params[0].format('MM/DD/YYYY'))\n  },\n  after_or_equal: {\n    message: 'The :attribute must be after or on :date.',\n    rule: (val, params) =>\n      canUseMoment() &&\n      // eslint-disable-next-line no-undef\n      moment.isMoment(val) &&\n      val.isSameOrAfter(params[0], 'day'),\n    messageReplace: (message, params) =>\n      message.replace(':date', params[0].format('MM/DD/YYYY'))\n  },\n  alpha: {\n    message: 'The :attribute may only contain letters.',\n    rule: (val) => testRegex(val, /^[A-Z]*$/i)\n  },\n  alpha_space: {\n    message: 'The :attribute may only contain letters and spaces.',\n    rule: (val) => testRegex(val, /^[A-Z\\s]*$/i)\n  },\n  alpha_num: {\n    message: 'The :attribute may only contain letters and numbers.',\n    rule: (val) => testRegex(val, /^[A-Z0-9]*$/i)\n  },\n  alpha_num_space: {\n    message: 'The :attribute may only contain letters, numbers, and spaces.',\n    rule: (val) => testRegex(val, /^[A-Z0-9\\s]*$/i)\n  },\n  alpha_num_dash: {\n    message: 'The :attribute may only contain letters, numbers, and dashes.',\n    rule: (val) => testRegex(val, /^[A-Z0-9_-]*$/i)\n  },\n  alpha_num_dash_space: {\n    message:\n      'The :attribute may only contain letters, numbers, dashes, and spaces.',\n    rule: (val) => testRegex(val, /^[A-Z0-9_-\\s]*$/i)\n  },\n  array: {\n    message: 'The :attribute must be an array.',\n    rule: (val) => Array.isArray(val)\n  },\n  before: {\n    message: 'The :attribute must be before :date.',\n    rule: (val, params) =>\n      // eslint-disable-next-line no-undef\n      canUseMoment() && moment.isMoment(val) && val.isBefore(params[0], 'day'),\n    messageReplace: (message, params) =>\n      message.replace(':date', params[0].format('MM/DD/YYYY'))\n  },\n  before_or_equal: {\n    message: 'The :attribute must be before or on :date.',\n    rule: (val, params) =>\n      canUseMoment() &&\n      // eslint-disable-next-line no-undef\n      moment.isMoment(val) &&\n      val.isSameOrBefore(params[0], 'day'),\n    messageReplace: (message, params) =>\n      message.replace(':date', params[0].format('MM/DD/YYYY'))\n  },\n  between: {\n    message: 'The :attribute must be between :min and :max:type.',\n    rule: (val, params) =>\n      size(val, params[2]) >= parseFloat(params[0]) &&\n      size(val, params[2]) <= parseFloat(params[1]),\n    messageReplace: (message, params) =>\n      message\n        .replace(':min', params[0])\n        .replace(':max', params[1])\n        .replace(':type', sizeText(params[2]))\n  },\n  boolean: {\n    message: 'The :attribute must be a boolean.',\n    rule: (val) => val === false || val === true\n  },\n  card_exp: {\n    message: 'The :attribute must be a valid expiration date.',\n    rule: (val) =>\n      testRegex(val, /^(([0]?[1-9]{1})|([1]{1}[0-2]{1}))\\s?\\/\\s?(\\d{2}|\\d{4})$/)\n  },\n  card_num: {\n    message: 'The :attribute must be a valid credit card number.',\n    rule: (val) => testRegex(val, /^\\d{4}\\s?\\d{4,6}\\s?\\d{4,5}\\s?\\d{0,8}$/)\n  },\n  currency: {\n    message: 'The :attribute must be a valid currency.',\n    rule: (val) => testRegex(val, /^\\$?(\\d{1,3})(\\,?\\d{3})*\\.?\\d{0,2}$/)\n  },\n  date: {\n    message: 'The :attribute must be a date.',\n    // eslint-disable-next-line no-undef\n    rule: (val) => canUseMoment() && moment.isMoment(val)\n  },\n  date_equals: {\n    message: 'The :attribute must be on :date.',\n    rule: (val, params) =>\n      // eslint-disable-next-line no-undef\n      canUseMoment() && moment.isMoment(val) && val.isSame(params[0], 'day'),\n    messageReplace: (message, params) =>\n      message.replace(':date', params[0].format('MM/DD/YYYY'))\n  },\n  email: {\n    message: 'The :attribute must be a valid email address.',\n    rule: (val) =>\n      testRegex(val, /^[A-Z0-9.!#$%&'*+-/=?^_`{|}~]+@[A-Z0-9.-]+\\.[A-Z]{2,}$/i)\n  },\n  in: {\n    message: 'The selected :attribute must be :values.',\n    rule: (val, params) => params.includes(val),\n    messageReplace: (message, params) =>\n      message.replace(':values', toSentence(params))\n  },\n  integer: {\n    message: 'The :attribute must be an integer.',\n    rule: (val) => testRegex(val, /^\\d*$/)\n  },\n  max: {\n    message: 'The :attribute may not be greater than :max:type.',\n    rule: (val, params) => size(val, params[1]) <= parseFloat(params[0]),\n    messageReplace: (message, params) =>\n      message.replace(':max', params[0]).replace(':type', sizeText(params[1]))\n  },\n  min: {\n    message: 'The :attribute must be at least :min:type.',\n    rule: (val, params) => size(val, params[1]) >= parseFloat(params[0]),\n    messageReplace: (message, params) =>\n      message.replace(':min', params[0]).replace(':type', sizeText(params[1]))\n  },\n  not_in: {\n    message: 'The selected :attribute must not be :values.',\n    rule: (val, params) => !params.includes(val),\n    messageReplace: (message, params) =>\n      message.replace(':values', toSentence(params))\n  },\n  not_regex: {\n    message: 'The :attribute must not match the required pattern.',\n    rule: (val, params) =>\n      !testRegex(\n        val,\n        typeof params[0] === 'string' || params[0] instanceof String\n          ? new RegExp(params[0])\n          : params[0]\n      )\n  },\n  numeric: {\n    message: 'The :attribute must be a number.',\n    rule: (val) => testRegex(val, /^\\-?\\d*\\.?\\d+$/)\n  },\n  phone: {\n    message: 'The :attribute must be a valid phone number.',\n    rule: (val) =>\n      testRegex(\n        val,\n        /^(\\+?\\d{0,4})?\\s?-?\\s?(\\(?\\d{3}\\)?)\\s?-?\\s?(\\(?\\d{3}\\)?)\\s?-?\\s?(\\(?\\d{4}\\)?)$/\n      ) && !testRegex(val, /^\\b(\\d)\\1{8,}\\b$/)\n  },\n  regex: {\n    message: 'The :attribute must match the required pattern.',\n    rule: (val, params) =>\n      testRegex(\n        val,\n        typeof params[0] === 'string' || params[0] instanceof String\n          ? new RegExp(params[0])\n          : params[0]\n      )\n  },\n  required: {\n    message: 'The :attribute field is required.',\n    rule: (val) => !isBlank(val),\n    required: true\n  },\n  size: {\n    message: 'The :attribute must be :size:type.',\n    rule: (val, params) => size(val, params[1]) == parseFloat(params[0]),\n    messageReplace: (message, params) =>\n      message.replace(':size', params[0]).replace(':type', sizeText(params[1]))\n  },\n  string: {\n    message: 'The :attribute must be a string.',\n    rule: (val) => typeof val === typeof 'string'\n  },\n  typeof: {\n    message: 'The :attribute is not the correct type of :type.',\n    rule: (val, params) => typeof val === typeof params[0],\n    messageReplace: (message, params) =>\n      message.replace(':type', typeof params[0])\n  },\n  url: {\n    message: 'The :attribute must be a url.',\n    rule: (val) =>\n      testRegex(\n        val,\n        /^https?:\\/\\/[-a-z0-9@:%._\\+~#=]{1,256}\\.[a-z0-9()]{2,6}\\b([-a-z0-9()@:%_\\+.~#?&//=]*)$/i\n      )\n  }\n}\n","import { useState } from 'react'\nimport validators from '../utils/validators'\nimport { getMessage, normalizeValues, passes } from '../utils/helpers'\n\nexport default (initialValue, validations, options = { fieldName: '' }) => {\n  const [state, setState] = useState(initialValue)\n  const [errors, setErrors] = useState([])\n\n  const dispatch = (newValue) => {\n    const validationList = Array.isArray(validations)\n      ? validations\n      : validations.split('|')\n    const errorList = []\n    for (const validation of validationList) {\n      const [value, rule, params] = normalizeValues(newValue, validation)\n      const rules = options.validators\n        ? { ...validators, ...options.validators }\n        : validators\n      if (!passes(rule, value, params, rules)) {\n        let message = getMessage(rule, options.fieldName, options, rules)\n\n        // eslint-disable-next-line no-prototype-builtins\n        if (params.length > 0 && rules[rule].hasOwnProperty('messageReplace')) {\n          message = rules[rule].messageReplace(message, params)\n        }\n\n        errorList.push(message)\n      }\n    }\n\n    setErrors(errorList)\n    setState(newValue)\n  }\n\n  return [state, errors, dispatch]\n}\n","import React from 'react'\n\nimport { useValidatedState } from \"@teragon/react-form-validator\";\n\nconst App = () => {\n  const [name, nameErrors, setName ] = useValidatedState(\"\", \"string|required\");\n  const [email, emailErrors, setEmail ] = useValidatedState(\"\", \"email|required\");\n\n  return (\n    <div>\n      <div>\n        <label>Name</label>\n        <input value={name} onChange={event => setName(event.target.value)} />\n        {nameErrors.length > 0 &&\n          nameErrors.map((error, index) => (\n            <p key={index}>{error}</p>\n          ))\n        }\n      </div>\n      <div>\n        <label>Email</label>\n        <input value={email} onChange={event => setEmail(event.target.value)} />\n        {emailErrors.length > 0 &&\n        emailErrors.map((error, index) => (\n          <p key={index}>{error}</p>\n        ))\n        }\n      </div>\n    </div>\n  )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}
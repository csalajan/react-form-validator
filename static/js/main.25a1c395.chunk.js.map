{"version":3,"sources":["../../src/utils/helpers.js","../../src/validators/ValidatorBuilder.js","../../src/validators/AcceptedValidator.js","../../src/validators/AfterValidator.js","../../src/validators/AfterOrEqualValidator.js","../../src/validators/AlphaValidator.js","../../src/validators/AlphaSpaceValidator.js","../../src/validators/AlphaNumValidator.js","../../src/validators/AlphaNumSpaceValidator.js","../../src/validators/AlphaNumDashValidator.js","../../src/validators/AlphaNumDashSpaceValidator.js","../../src/validators/ArrayValidator.js","../../src/validators/BeforeOrEqualValidator.js","../../src/validators/BeforeValidator.js","../../src/validators/BetweenValidator.js","../../src/validators/BooleanValidator.js","../../src/validators/CardExpirationValidator.js","../../src/validators/CardNumberValidator.js","../../src/validators/CurrencyValidator.js","../../src/validators/DateEqualsValidator.js","../../src/validators/DateValidator.js","../../src/validators/EmailValidator.js","../../src/validators/IntegerValidator.js","../../src/utils/validators.js","../../src/validators/InValidator.js","../../src/validators/MaxValidator.js","../../src/validators/MinValidator.js","../../src/validators/NotInValidator.js","../../src/validators/NotRegexValidator.js","../../src/validators/NumericValidator.js","../../src/validators/PhoneValidator.js","../../src/validators/RegexValidator.js","../../src/validators/RequiredValidator.js","../../src/validators/SizeValidator.js","../../src/validators/StringValidator.js","../../src/validators/TypeOfValidator.js","../../src/validators/UrlValidator.js","../../src/hooks/useValidatedState.js","App.js","index.js"],"names":["passes","rule","value","params","rules","isRequired","isBlank","testRegex","regex","size","type","parseFloat","sizeText","canUseMoment","window","toSentence","arr","valueOrEmptyString","getValidation","validation","Object","getOptions","Array","getMessage","field","options","message","humanizeFieldName","normalizeValues","ValidatorBuilder","messageReplace","required","SimpleRegexValidatorBuilder","val","moment","accepted","after","after_or_equal","alpha","alpha_space","alpha_num","alpha_num_space","alpha_num_dash","alpha_num_dash_space","array","before","before_or_equal","between","boolean","card_exp","card_num","currency","date","date_equals","email","in","integer","max","min","not_in","not_regex","RegExp","numeric","phone","string","typeof","url","initialValue","validations","fieldName","useState","dispatch","newValue","validationList","errorList","validators","setErrors","setState","state","errors","App","useValidatedState","name","nameErrors","setName","emailErrors","setEmail","onChange","event","target","length","map","error","index","key","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.25a1c395.chunk.js","sourcesContent":["export const passes = (rule, value, params, rules) => {\n  // eslint-disable-next-line no-prototype-builtins\n  if (!rules.hasOwnProperty(rule)) {\n    return true;\n  }\n\n  if (!isRequired(rule, rules) && isBlank(value)) {\n    return true;\n  }\n\n  return rules[rule].rule(value, params) !== false;\n};\n\nexport const isRequired = (rule, rules) => {\n  // eslint-disable-next-line no-prototype-builtins\n  return rules[rule].hasOwnProperty('required') && rules[rule].required;\n};\n\nexport const isBlank = (value) => {\n  return (\n    typeof value === 'undefined' ||\n    value === null ||\n    testRegex(value, /^[\\s]*$/)\n  );\n};\n\nexport const testRegex = (value, regex) => {\n  return value.toString().match(regex) !== null;\n};\n\nexport const size = (value, type) => {\n  if (type === 'string' || type === undefined || type === 'array') {\n    return value.length;\n  } else if (type === 'num') {\n    return parseFloat(value);\n  }\n};\n\nexport const sizeText = (type) => {\n  if (type === 'string' || type === undefined) {\n    return ' characters';\n  } else if (type === 'array') {\n    return ' elements';\n  } else {\n    return '';\n  }\n};\n\nexport const canUseMoment = () => {\n  return !(!window || !window.moment);\n};\n\nexport const toSentence = (arr) => {\n  return (\n    arr.slice(0, -2).join(', ') +\n    (arr.slice(0, -2).length ? ', ' : '') +\n    arr.slice(-2).join(arr.length > 2 ? ', or ' : ' or ')\n  );\n};\n\nexport const valueOrEmptyString = (value) => {\n  return typeof value === 'undefined' || value === null ? '' : value;\n};\n\nexport const getValidation = (validation) => {\n  if (validation === Object(validation) && !!Object.keys(validation).length) {\n    return Object.keys(validation)[0];\n  } else {\n    return validation.split(':')[0];\n  }\n};\n\nexport const getOptions = (validation) => {\n  if (validation === Object(validation) && !!Object.values(validation).length) {\n    const params = Object.values(validation)[0];\n    return Array.isArray(params) ? params : [params];\n  } else {\n    const params = validation.split(':');\n    return params.length > 1 ? params[1].split(',') : [];\n  }\n};\n\nexport const humanizeFieldName = (field) =>\n  field\n    .replace(/([A-Z])/g, ' $1')\n    .replace(/_/g, ' ')\n    .toLowerCase();\n\nexport const getMessage = (rule, field, options, rules) => {\n  options.messages = options.messages || {};\n  const message =\n    options.messages[rule] || options.messages.default || rules[rule].message;\n  return message.replace(':attribute', humanizeFieldName(field));\n};\n\nexport const normalizeValues = (value, validation) => {\n  return [\n    valueOrEmptyString(value),\n    getValidation(validation),\n    getOptions(validation)\n  ];\n};\n","import { testRegex } from '../utils/helpers';\n\nconst ValidatorBuilder = (message, rule, messageReplace, required = false) => ({\n  message,\n  rule,\n  messageReplace,\n  required\n});\n\nexport const SimpleRegexValidatorBuilder = (message, regex) =>\n  ValidatorBuilder(message, (val) => testRegex(val, regex));\n\nexport default ValidatorBuilder;\n","import ValidatorBuilder from './ValidatorBuilder';\n\nexport default ValidatorBuilder(\n  'The :attribute must be accepted.',\n  (val) => val === true,\n  null,\n  true\n);\n","import ValidatorBuilder from './ValidatorBuilder';\nimport { canUseMoment } from '../utils/helpers';\n\nexport default ValidatorBuilder(\n  'The :attribute must be after :date.',\n  (val, params) =>\n    // eslint-disable-next-line no-undef\n    canUseMoment() && moment.isMoment(val) && val.isAfter(params[0], 'day'),\n  (message, params) => message.replace(':date', params[0].format('MM/DD/YYYY'))\n);\n","import ValidatorBuilder from './ValidatorBuilder';\nimport { canUseMoment } from '../utils/helpers';\n\nexport default ValidatorBuilder(\n  'The :attribute must be after or on :date.',\n  (val, params) =>\n    canUseMoment() &&\n    // eslint-disable-next-line no-undef\n    moment.isMoment(val) &&\n    val.isSameOrAfter(params[0], 'day'),\n  (message, params) => message.replace(':date', params[0].format('MM/DD/YYYY'))\n);\n","import { SimpleRegexValidatorBuilder } from './ValidatorBuilder';\n\nexport default SimpleRegexValidatorBuilder(\n  'The :attribute may only contain letters.',\n  /^[A-Z]*$/i\n);\n","import { SimpleRegexValidatorBuilder } from './ValidatorBuilder';\n\nexport default SimpleRegexValidatorBuilder(\n  'The :attribute may only contain letters and spaces.',\n  /^[A-Z\\s]*$/i\n);\n","import { SimpleRegexValidatorBuilder } from './ValidatorBuilder';\n\nexport default SimpleRegexValidatorBuilder(\n  'The :attribute may only contain letters and numbers.',\n  /^[A-Z0-9]*$/i\n);\n","import { SimpleRegexValidatorBuilder } from './ValidatorBuilder';\n\nexport default SimpleRegexValidatorBuilder(\n  'The :attribute may only contain letters, numbers, and spaces.',\n  /^[A-Z0-9\\s]*$/i\n);\n","import { SimpleRegexValidatorBuilder } from './ValidatorBuilder';\n\nexport default SimpleRegexValidatorBuilder(\n  'The :attribute may only contain letters, numbers, and dashes.',\n  /^[A-Z0-9_-]*$/i\n);\n","import { SimpleRegexValidatorBuilder } from './ValidatorBuilder';\n\nexport default SimpleRegexValidatorBuilder(\n  'The :attribute may only contain letters, numbers, dashes, and spaces.',\n  /^[A-Z0-9_-\\s]*$/i\n);\n","import ValidatorBuilder from './ValidatorBuilder';\n\nexport default ValidatorBuilder('The :attribute must be an array.', (val) =>\n  Array.isArray(val)\n);\n","import ValidatorBuilder from './ValidatorBuilder';\nimport { canUseMoment } from '../utils/helpers';\n\nexport default ValidatorBuilder(\n  'The :attribute must be before or on :date.',\n  (val, params) =>\n    canUseMoment() &&\n    // eslint-disable-next-line no-undef\n    moment.isMoment(val) &&\n    val.isSameOrBefore(params[0], 'day'),\n  (message, params) => message.replace(':date', params[0].format('MM/DD/YYYY'))\n);\n","import ValidatorBuilder from './ValidatorBuilder';\nimport { canUseMoment } from '../utils/helpers';\n\nexport default ValidatorBuilder(\n  'The :attribute must be before :date.',\n  (val, params) =>\n    // eslint-disable-next-line no-undef\n    canUseMoment() && moment.isMoment(val) && val.isBefore(params[0], 'day'),\n  (message, params) => message.replace(':date', params[0].format('MM/DD/YYYY'))\n);\n","import { size, sizeText } from '../utils/helpers';\nimport ValidatorBuilder from './ValidatorBuilder';\n\nexport default ValidatorBuilder(\n  'The :attribute must be between :min and :max:type.',\n  (val, params) =>\n    size(val, params[2]) >= parseFloat(params[0]) &&\n    size(val, params[2]) <= parseFloat(params[1]),\n  (message, params) =>\n    message\n      .replace(':min', params[0])\n      .replace(':max', params[1])\n      .replace(':type', sizeText(params[2]))\n);\n","import ValidatorBuilder from './ValidatorBuilder';\n\nexport default ValidatorBuilder(\n  'The :attribute must be a boolean.',\n  (val) => val === false || val === true\n);\n","import { SimpleRegexValidatorBuilder } from './ValidatorBuilder';\n\nexport default SimpleRegexValidatorBuilder(\n  'The :attribute must be a valid expiration date.',\n  /^(([0]?[1-9]{1})|([1]{1}[0-2]{1}))\\s?\\/\\s?(\\d{2}|\\d{4})$/\n);\n","import { SimpleRegexValidatorBuilder } from './ValidatorBuilder';\n\nexport default SimpleRegexValidatorBuilder(\n  'The :attribute must be a valid credit card number.',\n  /^\\d{4}\\s?\\d{4,6}\\s?\\d{4,5}\\s?\\d{0,8}$/\n);\n","import { SimpleRegexValidatorBuilder } from './ValidatorBuilder';\n\nexport default SimpleRegexValidatorBuilder(\n  'The :attribute must be a valid currency.',\n  /^\\$?(\\d{1,3})(\\,?\\d{3})*\\.?\\d{0,2}$/\n);\n","import { canUseMoment } from '../utils/helpers';\nimport ValidatorBuilder from './ValidatorBuilder';\n\nexport default ValidatorBuilder(\n  'The :attribute must be on :date.',\n  // eslint-disable-next-line no-undef\n  (val, params) =>\n    // eslint-disable-next-line no-undef\n    canUseMoment() && moment.isMoment(val) && val.isSame(params[0], 'day'),\n  (message, params) => message.replace(':date', params[0].format('MM/DD/YYYY'))\n);\n","import { canUseMoment } from '../utils/helpers';\nimport ValidatorBuilder from './ValidatorBuilder';\n\nexport default ValidatorBuilder(\n  'The :attribute must be a date.',\n  // eslint-disable-next-line no-undef\n  (val) => canUseMoment() && moment.isMoment(val)\n);\n","import { SimpleRegexValidatorBuilder } from './ValidatorBuilder';\n\nexport default SimpleRegexValidatorBuilder(\n  'The :attribute must be a valid email address.',\n  /^[A-Z0-9.!#$%&'*+-/=?^_`{|}~]+@[A-Z0-9.-]+\\.[A-Z]{2,}$/i\n);\n","import { SimpleRegexValidatorBuilder } from './ValidatorBuilder';\n\nexport default SimpleRegexValidatorBuilder(\n  'The :attribute must be an integer.',\n  /^\\d*$/\n);\n","import {\n  AcceptedValidator,\n  AfterOrEqualValidator,\n  AfterValidator,\n  AlphaNumDashSpaceValidator,\n  AlphaNumDashValidator,\n  AlphaNumSpaceValidator,\n  AlphaNumValidator,\n  AlphaSpaceValidator,\n  AlphaValidator,\n  ArrayValidator,\n  BeforeOrEqualValidator,\n  BeforeValidator,\n  BetweenValidator,\n  BooleanValidator,\n  CardExpirationValidator,\n  CardNumberValidator,\n  CurrencyValidator,\n  DateEqualsValidator,\n  DateValidator,\n  EmailValidator,\n  IntegerValidator,\n  InValidator,\n  MaxValidator,\n  MinValidator,\n  NotInValidator,\n  NotRegexValidator,\n  NumericValidator,\n  PhoneValidator,\n  RegexValidator,\n  RequiredValidator,\n  SizeValidator,\n  StringValidator,\n  TypeOfValidator,\n  UrlValidator\n} from '../validators';\n\nexport default {\n  accepted: AcceptedValidator,\n  after: AfterValidator,\n  after_or_equal: AfterOrEqualValidator,\n  alpha: AlphaValidator,\n  alpha_space: AlphaSpaceValidator,\n  alpha_num: AlphaNumValidator,\n  alpha_num_space: AlphaNumSpaceValidator,\n  alpha_num_dash: AlphaNumDashValidator,\n  alpha_num_dash_space: AlphaNumDashSpaceValidator,\n  array: ArrayValidator,\n  before: BeforeValidator,\n  before_or_equal: BeforeOrEqualValidator,\n  between: BetweenValidator,\n  boolean: BooleanValidator,\n  card_exp: CardExpirationValidator,\n  card_num: CardNumberValidator,\n  currency: CurrencyValidator,\n  date: DateValidator,\n  date_equals: DateEqualsValidator,\n  email: EmailValidator,\n  in: InValidator,\n  integer: IntegerValidator,\n  max: MaxValidator,\n  min: MinValidator,\n  not_in: NotInValidator,\n  not_regex: NotRegexValidator,\n  numeric: NumericValidator,\n  phone: PhoneValidator,\n  regex: RegexValidator,\n  required: RequiredValidator,\n  size: SizeValidator,\n  string: StringValidator,\n  typeof: TypeOfValidator,\n  url: UrlValidator\n};\n","import { toSentence } from '../utils/helpers';\nimport ValidatorBuilder from './ValidatorBuilder';\n\nexport default ValidatorBuilder(\n  'The selected :attribute must be :values.',\n  (val, params) => params.includes(val),\n  (message, params) => message.replace(':values', toSentence(params))\n);\n","import { size, sizeText } from '../utils/helpers';\nimport ValidatorBuilder from './ValidatorBuilder';\n\nexport default ValidatorBuilder(\n  'The :attribute may not be greater than :max:type.',\n  (val, params) => size(val, params[1]) <= parseFloat(params[0]),\n  (message, params) =>\n    message.replace(':max', params[0]).replace(':type', sizeText(params[1]))\n);\n","import { size, sizeText } from '../utils/helpers';\nimport ValidatorBuilder from './ValidatorBuilder';\n\nexport default ValidatorBuilder(\n  'The :attribute may not be greater than :max:type.',\n  (val, params) => size(val, params[1]) >= parseFloat(params[0]),\n  (message, params) =>\n    message.replace(':max', params[0]).replace(':type', sizeText(params[1]))\n);\n","import { toSentence } from '../utils/helpers';\nimport ValidatorBuilder from './ValidatorBuilder';\n\nexport default ValidatorBuilder(\n  'The selected :attribute must not be :values.',\n  (val, params) => !params.includes(val),\n  (message, params) => message.replace(':values', toSentence(params))\n);\n","import { testRegex } from '../utils/helpers';\nimport ValidatorBuilder from './ValidatorBuilder';\n\nexport default ValidatorBuilder(\n  'The :attribute must not match the required pattern.',\n  (val, params) =>\n    !testRegex(\n      val,\n      typeof params[0] === 'string' || params[0] instanceof String\n        ? new RegExp(params[0])\n        : params[0]\n    )\n);\n","import { SimpleRegexValidatorBuilder } from './ValidatorBuilder';\n\nexport default SimpleRegexValidatorBuilder(\n  'The :attribute must be a number.',\n  /^\\-?\\d*\\.?\\d+$/\n);\n","import { testRegex } from '../utils/helpers';\nimport ValidatorBuilder from './ValidatorBuilder';\n\nexport default ValidatorBuilder(\n  'The :attribute must be a valid phone number.',\n  (val) =>\n    testRegex(\n      val,\n      /^(\\+?\\d{0,4})?\\s?-?\\s?(\\(?\\d{3}\\)?)\\s?-?\\s?(\\(?\\d{3}\\)?)\\s?-?\\s?(\\(?\\d{4}\\)?)$/\n    ) && !testRegex(val, /^\\b(\\d)\\1{8,}\\b$/)\n);\n","import { testRegex } from '../utils/helpers';\nimport ValidatorBuilder from './ValidatorBuilder';\n\nexport default ValidatorBuilder(\n  'The :attribute must match the required pattern.',\n  (val, params) =>\n    testRegex(\n      val,\n      typeof params[0] === 'string' || params[0] instanceof String\n        ? new RegExp(params[0])\n        : params[0]\n    )\n);\n","import { isBlank } from '../utils/helpers';\nimport ValidatorBuilder from './ValidatorBuilder';\n\nexport default ValidatorBuilder(\n  'The :attribute field is required.',\n  (val) => !isBlank(val),\n  null,\n  true\n);\n","import { size, sizeText } from '../utils/helpers';\nimport ValidatorBuilder from './ValidatorBuilder';\n\nexport default ValidatorBuilder(\n  'The :attribute must be :size:type.',\n  // eslint-disable-next-line eqeqeq\n  (val, params) => size(val, params[1]) == parseFloat(params[0]),\n  (message, params) =>\n    message.replace(':size', params[0]).replace(':type', sizeText(params[1]))\n);\n","import ValidatorBuilder from './ValidatorBuilder';\n\nexport default ValidatorBuilder(\n  'The :attribute must be a string.',\n  (val) => typeof val === typeof 'string'\n);\n","import ValidatorBuilder from './ValidatorBuilder';\n\nexport default ValidatorBuilder(\n  'The :attribute is not the correct type of :type.',\n  (val, params) => typeof val === typeof params[0],\n  (message, params) => message.replace(':type', typeof params[0])\n);\n","import { SimpleRegexValidatorBuilder } from './ValidatorBuilder';\n\nexport default SimpleRegexValidatorBuilder(\n  'The :attribute must be a url.',\n  /^https?:\\/\\/[-a-z0-9@:%._\\+~#=]{1,256}\\.[a-z0-9()]{2,6}\\b([-a-z0-9()@:%_\\+.~#?&//=]*)$/i\n);\n","import { useState } from 'react';\nimport validators from '../utils/validators';\nimport { getMessage, normalizeValues, passes } from '../utils/helpers';\n\nexport default (initialValue, validations, options = { fieldName: '' }) => {\n  const [state, setState] = useState(initialValue);\n  const [errors, setErrors] = useState([]);\n\n  const dispatch = (newValue) => {\n    const validationList = Array.isArray(validations)\n      ? validations\n      : validations.split('|');\n    const errorList = [];\n    for (const validation of validationList) {\n      const [value, rule, params] = normalizeValues(newValue, validation);\n      const rules = options.validators\n        ? { ...validators, ...options.validators }\n        : validators;\n      if (!passes(rule, value, params, rules)) {\n        let message = getMessage(rule, options.fieldName, options, rules);\n\n        // eslint-disable-next-line no-prototype-builtins\n        if (params.length > 0 && rules[rule].hasOwnProperty('messageReplace')) {\n          message = rules[rule].messageReplace(message, params);\n        }\n\n        errorList.push(message);\n      }\n    }\n\n    setErrors(errorList);\n    setState(newValue);\n  };\n\n  return [state, errors, dispatch];\n};\n","import React from 'react'\r\n\r\nimport { useValidatedState } from \"@teragon/react-form-validator\";\r\n\r\nconst App = () => {\r\n  const [name, nameErrors, setName ] = useValidatedState(\"\", \"string|required\");\r\n  const [email, emailErrors, setEmail ] = useValidatedState(\"\", \"email|required\");\r\n\r\n  return (\r\n    <div>\r\n      <div>\r\n        <label>Name</label>\r\n        <input value={name} onChange={event => setName(event.target.value)} />\r\n        {nameErrors.length > 0 &&\r\n          nameErrors.map((error, index) => (\r\n            <p key={index}>{error}</p>\r\n          ))\r\n        }\r\n      </div>\r\n      <div>\r\n        <label>Email</label>\r\n        <input value={email} onChange={event => setEmail(event.target.value)} />\r\n        {emailErrors.length > 0 &&\r\n        emailErrors.map((error, index) => (\r\n          <p key={index}>{error}</p>\r\n        ))\r\n        }\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default App\r\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}
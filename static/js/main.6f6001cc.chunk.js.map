{"version":3,"sources":["../../src/utils/helpers.js","../../src/utils/validators.js","../../src/hooks/useValidatedState.js","App.js","index.js"],"names":["passes","rule","value","params","rules","isRequired","isBlank","testRegex","regex","size","type","parseFloat","sizeText","canUseMoment","window","toSentence","arr","valueOrEmptyString","getValidation","validation","Object","getOptions","Array","getMessage","field","options","message","humanizeFieldName","normalizeValues","accepted","val","required","after","moment","messageReplace","after_or_equal","alpha","alpha_space","alpha_num","alpha_num_space","alpha_num_dash","alpha_num_dash_space","array","before","before_or_equal","between","boolean","card_exp","card_num","currency","date","date_equals","email","in","integer","max","min","not_in","not_regex","RegExp","numeric","phone","string","typeof","url","initialValue","validations","fieldName","useState","dispatch","newValue","validationList","errorList","validators","setErrors","setState","state","errors","App","useValidatedState","name","nameErrors","setName","emailErrors","setEmail","onChange","event","target","length","map","error","index","key","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.6f6001cc.chunk.js","sourcesContent":["export const passes = (rule, value, params, rules) => {\n  if (!rules.hasOwnProperty(rule)) {\n    return true\n  }\n\n  if (!isRequired(rule, rules) && isBlank(value)) {\n    return true\n  }\n\n  return rules[rule].rule(value, params) !== false\n}\n\nexport const isRequired = (rule, rules) => {\n  return rules[rule].hasOwnProperty('required') && rules[rule].required\n}\n\nexport const isBlank = (value) => {\n  return (\n    typeof value === 'undefined' ||\n    value === null ||\n    testRegex(value, /^[\\s]*$/)\n  )\n}\n\nexport const testRegex = (value, regex) => {\n  return value.toString().match(regex) !== null\n}\n\nexport const size = (value, type) => {\n  if (type === 'string' || type === undefined || type === 'array') {\n    return value.length\n  } else if (type === 'num') {\n    return parseFloat(value)\n  }\n}\n\nexport const sizeText = (type) => {\n  if (type === 'string' || type === undefined) {\n    return ' characters'\n  } else if (type === 'array') {\n    return ' elements'\n  } else {\n    return ''\n  }\n}\n\nexport const canUseMoment = () => {\n  return !(!window || !window.moment)\n}\n\nexport const toSentence = (arr) => {\n  return (\n    arr.slice(0, -2).join(', ') +\n    (arr.slice(0, -2).length ? ', ' : '') +\n    arr.slice(-2).join(arr.length > 2 ? ', or ' : ' or ')\n  )\n}\n\nexport const valueOrEmptyString = (value) => {\n  return typeof value === 'undefined' || value === null ? '' : value\n}\n\nexport const getValidation = (validation) => {\n  if (validation === Object(validation) && !!Object.keys(validation).length) {\n    return Object.keys(validation)[0]\n  } else {\n    return validation.split(':')[0]\n  }\n}\n\nexport const getOptions = (validation) => {\n  if (validation === Object(validation) && !!Object.values(validation).length) {\n    const params = Object.values(validation)[0]\n    return Array.isArray(params) ? params : [params]\n  } else {\n    const params = validation.split(':')\n    return params.length > 1 ? params[1].split(',') : []\n  }\n}\n\nexport const humanizeFieldName = (field) =>\n  field\n    .replace(/([A-Z])/g, ' $1')\n    .replace(/_/g, ' ')\n    .toLowerCase()\n\nexport const getMessage = (rule, field, options, rules) => {\n  options.messages = options.messages || {}\n  const message =\n    options.messages[rule] || options.messages.default || rules[rule].message\n  return message.replace(':attribute', humanizeFieldName(field))\n}\n\nexport const normalizeValues = (value, validation) => {\n  return [\n    valueOrEmptyString(value),\n    getValidation(validation),\n    getOptions(validation)\n  ]\n}\n","import {\n  canUseMoment,\n  isBlank,\n  size,\n  sizeText,\n  testRegex,\n  toSentence\n} from './helpers'\n\nexport default {\n  accepted: {\n    message: 'The :attribute must be accepted.',\n    rule: (val) => val === true,\n    required: true\n  },\n  after: {\n    message: 'The :attribute must be after :date.',\n    rule: (val, params) =>\n      canUseMoment() && moment.isMoment(val) && val.isAfter(params[0], 'day'),\n    messageReplace: (message, params) =>\n      message.replace(':date', params[0].format('MM/DD/YYYY'))\n  },\n  after_or_equal: {\n    message: 'The :attribute must be after or on :date.',\n    rule: (val, params) =>\n      canUseMoment() &&\n      moment.isMoment(val) &&\n      val.isSameOrAfter(params[0], 'day'),\n    messageReplace: (message, params) =>\n      message.replace(':date', params[0].format('MM/DD/YYYY'))\n  },\n  alpha: {\n    message: 'The :attribute may only contain letters.',\n    rule: (val) => testRegex(val, /^[A-Z]*$/i)\n  },\n  alpha_space: {\n    message: 'The :attribute may only contain letters and spaces.',\n    rule: (val) => testRegex(val, /^[A-Z\\s]*$/i)\n  },\n  alpha_num: {\n    message: 'The :attribute may only contain letters and numbers.',\n    rule: (val) => testRegex(val, /^[A-Z0-9]*$/i)\n  },\n  alpha_num_space: {\n    message: 'The :attribute may only contain letters, numbers, and spaces.',\n    rule: (val) => testRegex(val, /^[A-Z0-9\\s]*$/i)\n  },\n  alpha_num_dash: {\n    message: 'The :attribute may only contain letters, numbers, and dashes.',\n    rule: (val) => testRegex(val, /^[A-Z0-9_-]*$/i)\n  },\n  alpha_num_dash_space: {\n    message:\n      'The :attribute may only contain letters, numbers, dashes, and spaces.',\n    rule: (val) => testRegex(val, /^[A-Z0-9_-\\s]*$/i)\n  },\n  array: {\n    message: 'The :attribute must be an array.',\n    rule: (val) => Array.isArray(val)\n  },\n  before: {\n    message: 'The :attribute must be before :date.',\n    rule: (val, params) =>\n      canUseMoment() && moment.isMoment(val) && val.isBefore(params[0], 'day'),\n    messageReplace: (message, params) =>\n      message.replace(':date', params[0].format('MM/DD/YYYY'))\n  },\n  before_or_equal: {\n    message: 'The :attribute must be before or on :date.',\n    rule: (val, params) =>\n      canUseMoment() &&\n      moment.isMoment(val) &&\n      val.isSameOrBefore(params[0], 'day'),\n    messageReplace: (message, params) =>\n      message.replace(':date', params[0].format('MM/DD/YYYY'))\n  },\n  between: {\n    message: 'The :attribute must be between :min and :max:type.',\n    rule: (val, params) =>\n      size(val, params[2]) >= parseFloat(params[0]) &&\n      size(val, params[2]) <= parseFloat(params[1]),\n    messageReplace: (message, params) =>\n      message\n        .replace(':min', params[0])\n        .replace(':max', params[1])\n        .replace(':type', sizeText(params[2]))\n  },\n  boolean: {\n    message: 'The :attribute must be a boolean.',\n    rule: (val) => val === false || val === true\n  },\n  card_exp: {\n    message: 'The :attribute must be a valid expiration date.',\n    rule: (val) =>\n      testRegex(val, /^(([0]?[1-9]{1})|([1]{1}[0-2]{1}))\\s?\\/\\s?(\\d{2}|\\d{4})$/)\n  },\n  card_num: {\n    message: 'The :attribute must be a valid credit card number.',\n    rule: (val) => testRegex(val, /^\\d{4}\\s?\\d{4,6}\\s?\\d{4,5}\\s?\\d{0,8}$/)\n  },\n  currency: {\n    message: 'The :attribute must be a valid currency.',\n    rule: (val) => testRegex(val, /^\\$?(\\d{1,3})(\\,?\\d{3})*\\.?\\d{0,2}$/)\n  },\n  date: {\n    message: 'The :attribute must be a date.',\n    rule: (val) => canUseMoment() && moment.isMoment(val)\n  },\n  date_equals: {\n    message: 'The :attribute must be on :date.',\n    rule: (val, params) =>\n      canUseMoment() && moment.isMoment(val) && val.isSame(params[0], 'day'),\n    messageReplace: (message, params) =>\n      message.replace(':date', params[0].format('MM/DD/YYYY'))\n  },\n  email: {\n    message: 'The :attribute must be a valid email address.',\n    rule: (val) =>\n      testRegex(val, /^[A-Z0-9.!#$%&'*+-/=?^_`{|}~]+@[A-Z0-9.-]+\\.[A-Z]{2,}$/i)\n  },\n  in: {\n    message: 'The selected :attribute must be :values.',\n    rule: (val, params) => params.includes(val),\n    messageReplace: (message, params) =>\n      message.replace(':values', toSentence(params))\n  },\n  integer: {\n    message: 'The :attribute must be an integer.',\n    rule: (val) => testRegex(val, /^\\d*$/)\n  },\n  max: {\n    message: 'The :attribute may not be greater than :max:type.',\n    rule: (val, params) => size(val, params[1]) <= parseFloat(params[0]),\n    messageReplace: (message, params) =>\n      message.replace(':max', params[0]).replace(':type', sizeText(params[1]))\n  },\n  min: {\n    message: 'The :attribute must be at least :min:type.',\n    rule: (val, params) => size(val, params[1]) >= parseFloat(params[0]),\n    messageReplace: (message, params) =>\n      message.replace(':min', params[0]).replace(':type', sizeText(params[1]))\n  },\n  not_in: {\n    message: 'The selected :attribute must not be :values.',\n    rule: (val, params) => !params.includes(val),\n    messageReplace: (message, params) =>\n      message.replace(':values', toSentence(params))\n  },\n  not_regex: {\n    message: 'The :attribute must not match the required pattern.',\n    rule: (val, params) =>\n      !testRegex(\n        val,\n        typeof params[0] === 'string' || params[0] instanceof String\n          ? new RegExp(params[0])\n          : params[0]\n      )\n  },\n  numeric: {\n    message: 'The :attribute must be a number.',\n    rule: (val) => testRegex(val, /^\\-?\\d*\\.?\\d+$/)\n  },\n  phone: {\n    message: 'The :attribute must be a valid phone number.',\n    rule: (val) =>\n      testRegex(\n        val,\n        /^(\\+?\\d{0,4})?\\s?-?\\s?(\\(?\\d{3}\\)?)\\s?-?\\s?(\\(?\\d{3}\\)?)\\s?-?\\s?(\\(?\\d{4}\\)?)$/\n      ) && !testRegex(val, /^\\b(\\d)\\1{8,}\\b$/)\n  },\n  regex: {\n    message: 'The :attribute must match the required pattern.',\n    rule: (val, params) =>\n      testRegex(\n        val,\n        typeof params[0] === 'string' || params[0] instanceof String\n          ? new RegExp(params[0])\n          : params[0]\n      )\n  },\n  required: {\n    message: 'The :attribute field is required.',\n    rule: (val) => !isBlank(val),\n    required: true\n  },\n  size: {\n    message: 'The :attribute must be :size:type.',\n    rule: (val, params) => size(val, params[1]) == parseFloat(params[0]),\n    messageReplace: (message, params) =>\n      message.replace(':size', params[0]).replace(':type', sizeText(params[1]))\n  },\n  string: {\n    message: 'The :attribute must be a string.',\n    rule: (val) => typeof val === typeof 'string'\n  },\n  typeof: {\n    message: 'The :attribute is not the correct type of :type.',\n    rule: (val, params) => typeof val === typeof params[0],\n    messageReplace: (message, params) =>\n      message.replace(':type', typeof params[0])\n  },\n  url: {\n    message: 'The :attribute must be a url.',\n    rule: (val) =>\n      testRegex(\n        val,\n        /^https?:\\/\\/[-a-z0-9@:%._\\+~#=]{1,256}\\.[a-z0-9()]{2,6}\\b([-a-z0-9()@:%_\\+.~#?&//=]*)$/i\n      )\n  }\n}\n","import { useState } from 'react'\nimport validators from '../utils/validators'\nimport { getMessage, normalizeValues, passes } from '../utils/helpers'\n\nexport default (initialValue, validations, options = { fieldName: ''}) => {\n  const [state, setState] = useState(initialValue)\n  const [errors, setErrors] = useState([])\n\n  const dispatch = (newValue) => {\n    const validationList = Array.isArray(validations)\n      ? validations\n      : validations.split('|')\n    const errorList = []\n    for (const validation of validationList) {\n      const [value, rule, params] = normalizeValues(newValue, validation)\n      const rules = options.validators\n        ? { ...validators, ...options.validators }\n        : validators\n      if (!passes(rule, value, params, rules)) {\n        let message = getMessage(rule, options.fieldName, options, rules)\n\n        if (params.length > 0 && rules[rule].hasOwnProperty('messageReplace')) {\n          message = rules[rule].messageReplace(message, params)\n        }\n\n        errorList.push(message)\n      }\n    }\n\n    setErrors(errorList)\n    setState(newValue)\n  }\n\n  return [state, errors, dispatch]\n}\n","import React from 'react'\n\nimport '@teragon/react-form-validator/dist/index.css'\nimport { useValidatedState } from \"@teragon/react-form-validator\";\n\nconst App = () => {\n  const [name, nameErrors, setName ] = useValidatedState(\"\", \"string|required\");\n  const [email, emailErrors, setEmail ] = useValidatedState(\"\", \"email|required\");\n\n  return (\n    <div>\n      <div>\n        <label>Name</label>\n        <input value={name} onChange={event => setName(event.target.value)} />\n        {nameErrors.length > 0 &&\n          nameErrors.map((error, index) => (\n            <p key={index}>{error}</p>\n          ))\n        }\n      </div>\n      <div>\n        <label>Email</label>\n        <input value={email} onChange={event => setEmail(event.target.value)} />\n        {emailErrors.length > 0 &&\n        emailErrors.map((error, index) => (\n          <p key={index}>{error}</p>\n        ))\n        }\n      </div>\n    </div>\n  )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}